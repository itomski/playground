package de.lubowiecki.pruefung;

public class DatentypenTest {

    public static void main(String[] args) {

        int i = 10;
        double j = 10.0; // Zahlen mit Nachkommastelle sind automatisch vom Typ double
        float k = 10.0f; // f = float
        // k = 10.0; // Error. 10.0 ist double und daher zu Groß für float

        long l = 10; // 10 ist ein int d.h. kleiner als long, daher primitive widening zu long
        // int ist der Standard für Ganzzahlen
        //l = 10_000_000_000; // Error: Das Literal ist kein gültiger int (zu hoher Wert)
        l = 10_000_000_000l; // Das Literal ist jetzt ein long

        //byte b = 200; // Error: Byte-Umfang -128 bis 127
        String s = "Hallo Welt";
        // s = 'Hallo Welt'; // Error: ein char, muss 1 Zeichen sein! char ist kein String

        // Wird durch Cast ein hoher Wert in einen zu keinen Typ umgewandelt kommt es zu Überfüllung
        int ii = (int)100_000_000_000l; // Der long-Literal wird vor der Zuweisung zu int umgewandelt
        System.out.println(ii);

        // Standard für Ganzzahlen: int/Integer
        // Standard für Zahlen mit Nachkommastelle: double/Double

        // byte < short < int < long < float < double
        //         char <

        float ff1 = 10.0f;
        float ff2 = (float)10.0;
        float ff3 = 10; // int ist kleiner als float, daher primitive widening
        float ff4 = 10_000_000_000l; // OK
        System.out.println(ff4);

        Integer iii = 100; // int Autoboxing zu Integer (immer nur zum eigenen Wrapper)
        // Double ddd = 100; // Error: int Autoboxing zu Integer danach komplex Widening von Integer auf Double (Error)

    }
}
